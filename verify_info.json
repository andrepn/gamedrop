{
  "standard_json_input": {
    "language": "Solidity",
    "sources": {
      "RaffleContract.sol": {
        "content": "pragma solidity >=0.8.0 <0.9.0;\n//SPDX-License-Identifier: MIT\n\nimport \"Ownable.sol\";\nimport \"SafeMath.sol\";\nimport \"IERC20.sol\";\nimport \"IERC721.sol\";\nimport \"UniformRandomNumber.sol\";\nimport \"SortitionSumTreeFactory.sol\";\nimport \"IGVRF.sol\";\n\n// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol\n\n/*TODO:\nupgrade to safemath\nupgrade to upgradeable\n*/\n\n/*\nCONTRACT GAMEDROP RAFFLE\n*/\n\ncontract RaffleContract is Ownable {\n    //libraries\n    using SortitionSumTreeFactory for SortitionSumTreeFactory.SortitionSumTrees;\n\n    //constansts and variables for sortition\n    bytes32 private constant TREE_KEY = keccak256(\"Gamedrop/Raffle\");\n    uint256 private constant MAX_TREE_LEAVES = 5; //chose this constant to balance cost of read vs write. Could be optimized with data\n    SortitionSumTreeFactory.SortitionSumTrees internal sortition_sum_trees;\n\n    //structs\n    struct NFT {\n        IERC721 nft_contract;\n        uint256 token_id;\n    }\n    struct NextEpochBalanceUpdate {\n        address user;\n        uint256 new_balance;\n    }\n\n    //contract interfaces\n    IERC20 public gaming_test_token;\n    IGVRF public gamedrop_vrf_contract;\n\n    //variables for raffle\n    uint256 total_token_entered;\n    uint256 total_time_weighted_balance;\n    uint256 last_raffle_time;\n    bytes32 current_random_request_id;\n\n    //variables for claimable prize\n    address public most_recent_raffle_winner;\n    NFT public most_recent_prize;\n\n    //array for owned NFTs\n    NFT[] public vaultedNFTs;\n    mapping(IERC721 => mapping(uint256 => bool)) is_NFT_in_vault;\n    mapping(IERC721 => mapping(uint256 => uint256)) index_of_nft_in_array;\n\n    //array to hold instructions for updating balances post raffle and mappings\n    address[] next_epoch_balance_instructions;\n    mapping(address => bool) is_user_already_in_next_epoch_array;\n    mapping(address => uint256) user_to_old_balance;\n    mapping(address => uint256) user_to_new_balance;\n\n    //token and time weighted balances\n    mapping(address => uint256) public raw_balances;\n\n    //whitelists\n    mapping(address => bool) private _address_whitelist;\n    mapping(IERC721 => bool) private _nft_whitelist;\n\n    event depositMade(\n        address sender,\n        uint256 amount,\n        uint256 total_token_entered\n    );\n    event withdrawMade(\n        address sender,\n        uint256 amount,\n        uint256 total_token_entered\n    );\n    event NFTVaulted(address sender, IERC721 nft_contract, uint256 token_id);\n    event AddressWhitelist(address whitelist_address);\n    event NFTWhitelist(IERC721 nft_address);\n    event NFTsent(\n        address nft_recipient,\n        IERC721 nft_contract_address,\n        uint256 token_id\n    );\n    event raffleInitiated(uint256 time, bytes32 request_id, address initiator);\n    event raffleCompleted(uint256 time, address winner, NFT prize);\n\n    constructor(address _deposit_token) {\n        //initiate countdown to raffle at deploy time\n        last_raffle_time = block.timestamp;\n\n        //initialize total_token_entered at 0\n        total_token_entered = 0;\n\n        //initialize ERC20 interface (in production this will be yield guild)\n        gaming_test_token = IERC20(_deposit_token);\n\n        //initialize sortition_sum_trees\n        sortition_sum_trees.createTree(TREE_KEY, MAX_TREE_LEAVES);\n    }\n\n    modifier addRaffleBalance(uint256 amount) {\n        // declare time_between_raffles in memory in two functions to save gas\n        uint256 time_between_raffles = 604800;\n        uint256 time_until_next_raffle = (time_between_raffles -\n            (block.timestamp - last_raffle_time));\n        uint256 updated_balance = time_until_next_raffle * amount;\n\n        raw_balances[msg.sender] += amount;\n\n        // creates or updates node in sortition tree for time weighted odds of user\n        sortition_sum_trees.set(\n            TREE_KEY,\n            updated_balance,\n            bytes32(uint256(uint160(msg.sender)))\n        );\n\n        _;\n\n        uint256 next_balance = raw_balances[msg.sender] * time_between_raffles;\n\n        user_to_old_balance[msg.sender] = updated_balance;\n        user_to_new_balance[msg.sender] = next_balance;\n\n        if (is_user_already_in_next_epoch_array[msg.sender] == false) {\n            next_epoch_balance_instructions.push(msg.sender);\n        }\n\n        total_time_weighted_balance += time_until_next_raffle * amount;\n    }\n\n    modifier subtractRaffleBalance(uint256 amount) {\n        // declare time_between_raffles in memory in two functions to save gas\n        uint256 time_between_raffles = 604800;\n        uint256 time_until_next_raffle = (time_between_raffles -\n            (block.timestamp - last_raffle_time));\n        uint256 updated_balance = time_until_next_raffle * amount;\n\n        raw_balances[msg.sender] -= amount;\n\n        // creates node in sortition tree for time weighted odds of user\n        sortition_sum_trees.set(\n            TREE_KEY,\n            updated_balance,\n            bytes32(uint256(uint160(msg.sender)))\n        );\n\n        _;\n\n        uint256 next_balance = raw_balances[msg.sender] * time_between_raffles;\n\n        user_to_old_balance[msg.sender] = updated_balance;\n        user_to_new_balance[msg.sender] = next_balance;\n\n        //if user is not already in list then add them\n        if (is_user_already_in_next_epoch_array[msg.sender] == false) {\n            next_epoch_balance_instructions.push(msg.sender);\n        }\n\n        total_time_weighted_balance -= time_until_next_raffle * amount;\n    }\n\n    function Deposit(uint256 amount) public payable addRaffleBalance(amount) {\n        require(amount > 0, \"Cannot stake 0\");\n        require(gaming_test_token.balanceOf(msg.sender) >= amount);\n\n        // approval required on front end\n        bool sent = gaming_test_token.transferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n        require(sent, \"Failed to transfer tokens from user to vendor\");\n\n        total_token_entered += amount;\n\n        emit depositMade(msg.sender, amount, total_token_entered);\n    }\n\n    function Withdraw(uint256 amount)\n        public\n        payable\n        subtractRaffleBalance(amount)\n    {\n        require(amount > 0, \"Cannot withdraw 0\");\n        require(\n            raw_balances[msg.sender] >= amount,\n            \"Cannot withdraw more than you own\"\n        );\n\n        bool withdrawn = gaming_test_token.transfer(msg.sender, amount);\n        require(withdrawn, \"Failed to withdraw tokens from contract to user\");\n\n        total_token_entered -= amount;\n\n        emit withdrawMade(msg.sender, amount, total_token_entered);\n    }\n\n    function vaultNFT(IERC721 nft_contract_address, uint256 token_id) public {\n        require(\n            _address_whitelist[msg.sender],\n            \"Address not whitelisted to contribute NFTS, to whitelist your address reach out to Joe\"\n        );\n        require(\n            _nft_whitelist[nft_contract_address],\n            \"This NFT type is not whitelisted currently, to add your NFT reach out to Joe\"\n        );\n\n        IERC721 nft_contract = nft_contract_address;\n        // here we need to request and send approval to transfer token\n        nft_contract.transferFrom(msg.sender, address(this), token_id);\n\n        NFT memory new_nft = NFT({\n            nft_contract: nft_contract,\n            token_id: token_id\n        });\n        vaultedNFTs.push(new_nft);\n\n        //tracking\n        uint256 index = vaultedNFTs.length - 1;\n        is_NFT_in_vault[nft_contract][token_id] = true;\n        index_of_nft_in_array[nft_contract][token_id] = index;\n\n        emit NFTVaulted(msg.sender, nft_contract_address, token_id);\n    }\n\n    modifier isWinner() {\n        require(msg.sender == most_recent_raffle_winner);\n        _;\n    }\n\n    modifier prizeUnclaimed() {\n        require(\n            is_NFT_in_vault[most_recent_prize.nft_contract][\n                most_recent_prize.token_id\n            ],\n            \"prize already claimed\"\n        );\n        _;\n    }\n\n    modifier removeNFTFromArray() {\n        _;\n        uint256 index = index_of_nft_in_array[most_recent_prize.nft_contract][\n            most_recent_prize.token_id\n        ];\n        uint256 last_index = vaultedNFTs.length - 1;\n\n        vaultedNFTs[index] = vaultedNFTs[last_index];\n        vaultedNFTs.pop();\n        is_NFT_in_vault[most_recent_prize.nft_contract][\n            most_recent_prize.token_id\n        ] = false;\n    }\n\n    function claimPrize() external isWinner prizeUnclaimed removeNFTFromArray {\n        _sendNFTFromVault(\n            most_recent_prize.nft_contract,\n            most_recent_prize.token_id,\n            msg.sender\n        );\n    }\n\n    //make claimable so they have to pay the gas\n    function _sendNFTFromVault(\n        IERC721 nft_contract_address,\n        uint256 token_id,\n        address nft_recipient\n    ) internal {\n        IERC721 nft_contract = nft_contract_address;\n        nft_contract.approve(nft_recipient, token_id);\n        nft_contract.transferFrom(address(this), nft_recipient, token_id);\n\n        emit NFTsent(nft_recipient, nft_contract_address, token_id);\n    }\n\n    function initiateRaffle() external returns (bytes32) {\n        require(vaultedNFTs.length > 0, \"no NFTs to raffle\");\n\n        current_random_request_id = gamedrop_vrf_contract.getRandomNumber();\n\n        emit raffleInitiated(\n            block.timestamp,\n            current_random_request_id,\n            msg.sender\n        );\n\n        return current_random_request_id;\n    }\n\n    modifier _updateBalancesAfterRaffle() {\n        _;\n\n        uint256 x;\n\n        for (x = 0; x < next_epoch_balance_instructions.length; x++) {\n            address user = next_epoch_balance_instructions[x];\n            uint256 next_balance = user_to_new_balance[user];\n\n            sortition_sum_trees.set(\n                TREE_KEY,\n                next_balance,\n                bytes32(uint256(uint160(user)))\n            );\n\n            uint256 old_balance = user_to_old_balance[user];\n            total_time_weighted_balance += next_balance - old_balance;\n        }\n\n        delete next_epoch_balance_instructions;\n    }\n\n    function _chooseWinner(uint256 random_number) internal returns (address) {\n        //set range for the uniform random number\n        uint256 bound = total_time_weighted_balance;\n        address selected;\n\n        if (bound == 0) {\n            selected = address(0);\n        } else {\n            uint256 number = UniformRandomNumber.uniform(random_number, bound);\n            selected = address(\n                (uint160(uint256(sortition_sum_trees.draw(TREE_KEY, number))))\n            );\n        }\n        return selected;\n    }\n\n    function _chooseNFT(uint256 random_number) internal returns (NFT memory) {\n        uint256 bound = vaultedNFTs.length;\n        uint256 index_of_nft;\n\n        index_of_nft = UniformRandomNumber.uniform(random_number, bound);\n\n        return vaultedNFTs[index_of_nft];\n    }\n\n    function completeRaffle(uint256 random_number)\n        external\n        _updateBalancesAfterRaffle\n    {\n        //updating these two variables makes the prize claimable by the winner\n        most_recent_raffle_winner = _chooseWinner(random_number);\n        most_recent_prize = _chooseNFT(random_number);\n\n        emit raffleCompleted(\n            block.timestamp,\n            most_recent_raffle_winner,\n            most_recent_prize\n        );\n    }\n\n    function updateGamedropVRFContract(IGVRF new_vrf_contract)\n        public\n        onlyOwner\n    {\n        gamedrop_vrf_contract = new_vrf_contract;\n    }\n\n    function addAddressToWhitelist(address whitelist_address) public onlyOwner {\n        _address_whitelist[whitelist_address] = true;\n\n        emit AddressWhitelist(whitelist_address);\n    }\n\n    function addNFTToWhitelist(IERC721 nft_whitelist_address) public {\n        require(msg.sender == owner(), \"sender not owner\");\n        _nft_whitelist[nft_whitelist_address] = true;\n\n        emit NFTWhitelist(nft_whitelist_address);\n    }\n\n    function view_raw_balance(address wallet_address)\n        public\n        view\n        returns (uint256)\n    {\n        return raw_balances[wallet_address];\n    }\n\n    function is_address_whitelisted(address wallet_address)\n        public\n        view\n        returns (bool)\n    {\n        return _address_whitelist[wallet_address];\n    }\n\n    function is_nft_whitelisted(IERC721 nft_contract)\n        public\n        view\n        returns (bool)\n    {\n        return _nft_whitelist[nft_contract];\n    }\n\n    function view_odds_of_winning(address user) public view returns (uint256) {\n        return\n            sortition_sum_trees.stakeOf(\n                TREE_KEY,\n                bytes32(uint256(uint160(user)))\n            );\n    }\n\n    function get_total_number_of_NFTS() public view returns (uint256) {\n        return vaultedNFTs.length;\n    }\n\n    function check_if_NFT_in_vault(IERC721 nft_contract, uint256 token_id)\n        public\n        view\n        returns (bool)\n    {\n        return is_NFT_in_vault[nft_contract][token_id];\n    }\n}\n"
      },
      "Ownable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
      },
      "Context.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
      },
      "SafeMath.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
      },
      "IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"IERC20.sol\";\n"
      },
      "IERC721.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"IERC721.sol\";\n"
      },
      "UniformRandomNumber.sol": {
        "content": "/**\nCopyright 2019 PoolTogether LLC\n\nThis file is part of PoolTogether.\n\nPoolTogether is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation under version 3 of the License.\n\nPoolTogether is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with PoolTogether.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.8.0 <0.9.0;\n//SPDX-License-Identifier: MIT\n\n/**\n * @author Brendan Asselstine\n * @notice A library that uses entropy to select a random number within a bound.  Compensates for modulo bias.\n * @dev Thanks to https://medium.com/hownetworks/dont-waste-cycles-with-modulo-bias-35b6fdafcf94\n */\nlibrary UniformRandomNumber {\n  /// @notice Select a random number without modulo bias using a random seed and upper bound\n  /// @param _entropy The seed for randomness\n  /// @param _upperBound The upper bound of the desired number\n  /// @return A random number less than the _upperBound\n  function uniform(uint256 _entropy, uint256 _upperBound) internal pure returns (uint256) {\n    require(_upperBound > 0, \"UniformRand/min-bound\");\n    uint256 min = _upperBound % (~_upperBound + 1);\n    uint256 random = _entropy;\n    while (true) {\n      if (random >= min) {\n        break;\n      }\n      random = uint256(keccak256(abi.encodePacked(random)));\n    }\n    return random % _upperBound;\n  }\n}"
      },
      "SortitionSumTreeFactory.sol": {
        "content": "/**\n *  @reviewers: [@clesaege, @unknownunknown1, @ferittuncer]\n *  @auditors: []\n *  @bounties: [<14 days 10 ETH max payout>]\n *  @deployments: []\n */\n\npragma solidity >=0.8.0 <0.9.0;\n//SPDX-License-Identifier: MIT\n\n/**\n *  @title SortitionSumTreeFactory\n *  @author Enrique Piqueras - <epiquerass@gmail.com>\n *  @dev A factory of trees that keep track of staked values for sortition.\n */\nlibrary SortitionSumTreeFactory {\n    /* Structs */\n\n    struct SortitionSumTree {\n        uint K; // The maximum number of childs per node.\n        // We use this to keep track of vacant positions in the tree after removing a leaf. This is for keeping the tree as balanced as possible without spending gas on moving nodes around.\n        uint[] stack;\n        uint[] nodes;\n        // Two-way mapping of IDs to node indexes. Note that node index 0 is reserved for the root node, and means the ID does not have a node.\n        mapping(bytes32 => uint) IDsToNodeIndexes;\n        mapping(uint => bytes32) nodeIndexesToIDs;\n    }\n\n    /* Storage */\n\n    struct SortitionSumTrees {\n        mapping(bytes32 => SortitionSumTree) sortitionSumTrees;\n    }\n\n    /* internal */\n\n    /**\n     *  @dev Create a sortition sum tree at the specified key.\n     *  @param _key The key of the new tree.\n     *  @param _K The number of children each node in the tree should have.\n     */\n    function createTree(SortitionSumTrees storage self, bytes32 _key, uint _K) internal {\n        SortitionSumTree storage tree = self.sortitionSumTrees[_key];\n        require(tree.K == 0, \"Tree already exists.\");\n        require(_K > 1, \"K must be greater than one.\");\n        tree.K = _K;\n        tree.stack = new uint[](0);\n        tree.nodes = new uint[](0);\n        tree.nodes.push(0);\n    }\n\n    /**\n     *  @dev Set a value of a tree.\n     *  @param _key The key of the tree.\n     *  @param _value The new value.\n     *  @param _ID The ID of the value.\n     *  `O(log_k(n))` where\n     *  `k` is the maximum number of childs per node in the tree,\n     *   and `n` is the maximum number of nodes ever appended.\n     */\n    function set(SortitionSumTrees storage self, bytes32 _key, uint _value, bytes32 _ID) internal {\n        SortitionSumTree storage tree = self.sortitionSumTrees[_key];\n        uint treeIndex = tree.IDsToNodeIndexes[_ID];\n\n        if (treeIndex == 0) { // No existing node.\n            if (_value != 0) { // Non zero value.\n                // Append.\n                // Add node.\n                if (tree.stack.length == 0) { // No vacant spots.\n                    // Get the index and append the value.\n                    treeIndex = tree.nodes.length;\n                    tree.nodes.push(_value);\n\n                    // Potentially append a new node and make the parent a sum node.\n                    if (treeIndex != 1 && (treeIndex - 1) % tree.K == 0) { // Is first child.\n                        uint parentIndex = treeIndex / tree.K;\n                        bytes32 parentID = tree.nodeIndexesToIDs[parentIndex];\n                        uint newIndex = treeIndex + 1;\n                        tree.nodes.push(tree.nodes[parentIndex]);\n                        delete tree.nodeIndexesToIDs[parentIndex];\n                        tree.IDsToNodeIndexes[parentID] = newIndex;\n                        tree.nodeIndexesToIDs[newIndex] = parentID;\n                    }\n                } else { // Some vacant spot.\n                    // Pop the stack and append the value.\n                    treeIndex = tree.stack[tree.stack.length - 1];\n                    tree.stack.pop();\n                    tree.nodes[treeIndex] = _value;\n                }\n\n                // Add label.\n                tree.IDsToNodeIndexes[_ID] = treeIndex;\n                tree.nodeIndexesToIDs[treeIndex] = _ID;\n\n                updateParents(self, _key, treeIndex, true, _value);\n            }\n        } else { // Existing node.\n            if (_value == 0) { // Zero value.\n                // Remove.\n                // Remember value and set to 0.\n                uint value = tree.nodes[treeIndex];\n                tree.nodes[treeIndex] = 0;\n\n                // Push to stack.\n                tree.stack.push(treeIndex);\n\n                // Clear label.\n                delete tree.IDsToNodeIndexes[_ID];\n                delete tree.nodeIndexesToIDs[treeIndex];\n\n                updateParents(self, _key, treeIndex, false, value);\n            } else if (_value != tree.nodes[treeIndex]) { // New, non zero value.\n                // Set.\n                bool plusOrMinus = tree.nodes[treeIndex] <= _value;\n                uint plusOrMinusValue = plusOrMinus ? _value - tree.nodes[treeIndex] : tree.nodes[treeIndex] - _value;\n                tree.nodes[treeIndex] = _value;\n\n                updateParents(self, _key, treeIndex, plusOrMinus, plusOrMinusValue);\n            }\n        }\n    }\n\n    /* internal Views */\n\n    /**\n     *  @dev Query the leaves of a tree. Note that if `startIndex == 0`, the tree is empty and the root node will be returned.\n     *  @param _key The key of the tree to get the leaves from.\n     *  @param _cursor The pagination cursor.\n     *  @param _count The number of items to return.\n     *  @return startIndex The index at which leaves start\n     *  @return values The values of the returned leaves\n     *  @return hasMore Whether there are more for pagination.\n     *  `O(n)` where\n     *  `n` is the maximum number of nodes ever appended.\n     */\n    function queryLeafs(\n        SortitionSumTrees storage self,\n        bytes32 _key,\n        uint _cursor,\n        uint _count\n    ) internal view returns(uint startIndex, uint[] memory values, bool hasMore) {\n        SortitionSumTree storage tree = self.sortitionSumTrees[_key];\n\n        // Find the start index.\n        for (uint i = 0; i < tree.nodes.length; i++) {\n            if ((tree.K * i) + 1 >= tree.nodes.length) {\n                startIndex = i;\n                break;\n            }\n        }\n\n        // Get the values.\n        uint loopStartIndex = startIndex + _cursor;\n        values = new uint[](loopStartIndex + _count > tree.nodes.length ? tree.nodes.length - loopStartIndex : _count);\n        uint valuesIndex = 0;\n        for (uint j = loopStartIndex; j < tree.nodes.length; j++) {\n            if (valuesIndex < _count) {\n                values[valuesIndex] = tree.nodes[j];\n                valuesIndex++;\n            } else {\n                hasMore = true;\n                break;\n            }\n        }\n    }\n\n    /**\n     *  @dev Draw an ID from a tree using a number. Note that this function reverts if the sum of all values in the tree is 0.\n     *  @param _key The key of the tree.\n     *  @param _drawnNumber The drawn number.\n     *  @return ID The drawn ID.\n     *  `O(k * log_k(n))` where\n     *  `k` is the maximum number of childs per node in the tree,\n     *   and `n` is the maximum number of nodes ever appended.\n     */\n    function draw(SortitionSumTrees storage self, bytes32 _key, uint _drawnNumber) internal view returns(bytes32 ID) {\n        SortitionSumTree storage tree = self.sortitionSumTrees[_key];\n        uint treeIndex = 0;\n        uint currentDrawnNumber = _drawnNumber % tree.nodes[0];\n\n        while ((tree.K * treeIndex) + 1 < tree.nodes.length)  // While it still has children.\n            for (uint i = 1; i <= tree.K; i++) { // Loop over children.\n                uint nodeIndex = (tree.K * treeIndex) + i;\n                uint nodeValue = tree.nodes[nodeIndex];\n\n                if (currentDrawnNumber >= nodeValue) currentDrawnNumber -= nodeValue; // Go to the next child.\n                else { // Pick this child.\n                    treeIndex = nodeIndex;\n                    break;\n                }\n            }\n        \n        ID = tree.nodeIndexesToIDs[treeIndex];\n    }\n\n    /** @dev Gets a specified ID's associated value.\n     *  @param _key The key of the tree.\n     *  @param _ID The ID of the value.\n     *  @return value The associated value.\n     */\n    function stakeOf(SortitionSumTrees storage self, bytes32 _key, bytes32 _ID) internal view returns(uint value) {\n        SortitionSumTree storage tree = self.sortitionSumTrees[_key];\n        uint treeIndex = tree.IDsToNodeIndexes[_ID];\n\n        if (treeIndex == 0) value = 0;\n        else value = tree.nodes[treeIndex];\n    }\n\n    function total(SortitionSumTrees storage self, bytes32 _key) internal view returns (uint) {\n        SortitionSumTree storage tree = self.sortitionSumTrees[_key];\n        if (tree.nodes.length == 0) {\n            return 0;\n        } else {\n            return tree.nodes[0];\n        }\n    }\n\n    /* Private */\n\n    /**\n     *  @dev Update all the parents of a node.\n     *  @param _key The key of the tree to update.\n     *  @param _treeIndex The index of the node to start from.\n     *  @param _plusOrMinus Wether to add (true) or substract (false).\n     *  @param _value The value to add or substract.\n     *  `O(log_k(n))` where\n     *  `k` is the maximum number of childs per node in the tree,\n     *   and `n` is the maximum number of nodes ever appended.\n     */\n    function updateParents(SortitionSumTrees storage self, bytes32 _key, uint _treeIndex, bool _plusOrMinus, uint _value) private {\n        SortitionSumTree storage tree = self.sortitionSumTrees[_key];\n\n        uint parentIndex = _treeIndex;\n        while (parentIndex != 0) {\n            parentIndex = (parentIndex - 1) / tree.K;\n            tree.nodes[parentIndex] = _plusOrMinus ? tree.nodes[parentIndex] + _value : tree.nodes[parentIndex] - _value;\n        }\n    }\n}\n"
      },
      "IGVRF.sol": {
        "content": "pragma solidity >=0.8.0 <0.9.0;\n//SPDX-License-Identifier: MIT\n\ninterface IGVRF {\n\n    function getRandomNumber() external returns (bytes32 requestId);\n\n    function getContractLinkBalance() external view returns (uint);\n\n    function getContractBalance() external view returns (uint);\n}"
      }
    },
    "settings": {
      "evmVersion": "istanbul",
      "optimizer": { "enabled": True, "runs": 200 }
    }
  },
  "contract_name": "RaffleContract",
  "compiler_version": "0.8.10+commit.fc410830",
  "optimizer_enabled": True,
  "optimizer_runs": 200,
  "license_identifier": "NONE",
  "bytecode_len": 18080
}
